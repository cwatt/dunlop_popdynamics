---
title: "Dunlop growth rates - groups"
author: "Cassandra Wattenburger"
date: "2/15/2021"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(results = "show")
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```

**Goal of this script:** Bimodal distributions of growth rate data may indicate diffring populations? Explore variables that may distinguish two groups within community.

Exploratory analysis.


# Import libraries

```{r}
library(tidyverse)
library(mixtools)

sessionInfo()

rm(list=ls())
```


# Import data

```{r}
growth <- readRDS("rdata.files/gr_gr.paprica.clean.rds")
```

Average across replicates to get a single estimated growth rate for each taxa.

```{r}
growth.asv <- growth %>%
  group_by(Soil, Amendment, ASV) %>%
  summarize(k = mean(k)) # average replicates for each taxa
```

Visualize distributions:

```{r}
growth.asv %>%
  ggplot(aes(x=log(k), color=Soil)) +
  geom_density() +
  facet_wrap(~Amendment) +
  theme_test()
```


# Grouping

I need an objective method to split possible populations based on this distribution. Since these distributions look like they may be a mixture of two gaussian distributions, I'll try to fit a finite mixture model to each to delineate them from one another.

See: 
* Explanation of finite mixed models: https://www.thedigitaltransformationpeople.com/channels/analytics/what-are-finite-mixture-models%E2%80%8B/
* Code hijacked from: https://tinyheero.github.io/2015/10/13/mixture-model.html

I'll attempt the water control treatment first, since the separation is more clear cut there.


**Successional water control**

Starting here because it is the most clear-cut example.

Fit model:

```{r}
# Isolate treatment
S17n <- growth.asv %>% 
  filter(Soil=="S17" & Amendment=="N")

# Fit model
S17n.mixfit <- normalmixEM(log(S17n$k), lambda = .5, mu = c(-2.8, -1), sigma = 0.3) # chose starting values by looking at the density graph
summary(S17n.mixfit)
# mu refers to distribution means
# sigma refers to standard deviation
# lambda refers to mixing weights (ie what proportion of data falls under distribution 1 and 2)
```

Visualize:

```{r}
plot(S17n.mixfit, density=TRUE)
```

Assign:

* Using a threshold of 0.5 because I have no reason to assume one group may be more represented than another

```{r}
# Get posterior probabilities for each observation
S17n.mixfit.post <- as.data.frame(cbind(x = S17n.mixfit$x, S17n.mixfit$posterior))

# Set threshold
# I'm just going to use 0.5, because that seems least biased

# Visualize breakdown of observations
S17n.mixfit.post %>%
  mutate(label = ifelse(comp.1 > 0.5, "slow", "fast")) %>% 
  ggplot(aes(x = factor(label))) +
  geom_bar() +
  xlab("Component") +
  ylab("Number of Data Points") +
  theme_test()

# Label
S17n.mixfit.post <- S17n.mixfit.post %>%
  mutate(label = ifelse(comp.1 > 0.5, "slow", "fast")) %>%
  add_column(Soil=c(rep("S17", nrow(.))), Amendment=c(rep("N", nrow(.)))) # add soil and amendment labels back
```


**Cropped water control**

Fit model:

```{r}
# Isolate treatment
C3n <- growth.asv %>% 
  filter(Soil=="C3" & Amendment=="N")

# Fit model
C3n.mixfit <- normalmixEM(log(C3n$k), lambda = .5, mu = c(-3, -1.3), sigma = 0.3) # chose starting values by looking at the density graph
summary(C3n.mixfit)
# mu refers to distribution means
# sigma refers to standard deviation
# lambda refers to mixing weights (ie what proportion of data falls under distribution 1 and 2)
```

Visualize:

```{r}
plot(C3n.mixfit, density=TRUE)
```

Assign:

* Using a threshold of 0.5 because I have no reason to assume one group may be more represented than another

```{r}
# Get posterior probabilities for each observation
C3n.mixfit.post <- as.data.frame(cbind(x = C3n.mixfit$x, C3n.mixfit$posterior))

# Set threshold
# I'm just going to use 0.5, because that seems least biased

# Visualize breakdown of observations
C3n.mixfit.post %>%
  mutate(label = ifelse(comp.1 > 0.5, "slow", "fast")) %>% 
  ggplot(aes(x = factor(label))) +
  geom_bar() +
  xlab("Component") +
  ylab("Number of Data Points") +
  theme_test()

# Label
C3n.mixfit.post <- C3n.mixfit.post %>%
  mutate(label = ifelse(comp.1 > 0.5, "slow", "fast")) %>%
  add_column(Soil=c(rep("C3", nrow(.))), Amendment=c(rep("N", nrow(.)))) # add soil and amendment labels back
```


**Successional C amended**

This will likely be trickier, if even possible.

Fit model:

```{r}
# Isolate treatment
S17y <- growth.asv %>% 
  filter(Soil=="S17" & Amendment=="Y")

# Fit model
S17y.mixfit <- normalmixEM(log(S17y$k), lambda = .5, mu = c(-2, -1), sigma = 0.3) # chose starting values by looking at the density graph
summary(S17y.mixfit)
# mu refers to distribution means
# sigma refers to standard deviation
# lambda refers to mixing weights (ie what proportion of data falls under distribution 1 and 2)
```

Visualize:

```{r}
plot(S17y.mixfit, density=TRUE)
```

Assign:

* Using a threshold of 0.5 because I have no reason to assume one group may be more represented than another

```{r}
# Get posterior probabilities for each observation
S17y.mixfit.post <- as.data.frame(cbind(x = S17y.mixfit$x, S17y.mixfit$posterior))

# Set threshold
# I'm just going to use 0.5, because that seems least biased

# Visualize breakdown of observations
S17y.mixfit.post %>%
  mutate(label = ifelse(comp.1 > 0.5, "slow", "fast")) %>% 
  ggplot(aes(x = factor(label))) +
  geom_bar() +
  xlab("Component") +
  ylab("Number of Data Points") +
  theme_test()

# Label
S17y.mixfit.post <- S17y.mixfit.post %>%
  mutate(label = ifelse(comp.1 > 0.5, "slow", "fast")) %>%
  add_column(Soil=c(rep("S17", nrow(.))), Amendment=c(rep("Y", nrow(.)))) # add soil and amendment labels back
```


**Cropped water control**

Fit model:

```{r}
library(mixtools)

# Isolate treatment
C3y <- growth.asv %>% 
  filter(Soil=="C3" & Amendment=="Y")

# Fit model
C3y.mixfit <- normalmixEM(log(C3y$k), lambda = .5, mu = c(-2, -1.5), sigma = 0.3) # chose starting values by looking at the density graph
summary(C3y.mixfit)
# mu refers to distribution means
# sigma refers to standard deviation
# lambda refers to mixing weights (ie what proportion of data falls under distribution 1 and 2)
```

Visualize:

```{r}
plot(C3y.mixfit, density=TRUE)
```

Assign:

* Using a threshold of 0.5 because I have no reason to assume one group may be more represented than another

```{r}
# Get posterior probabilities for each observation
C3y.mixfit.post <- as.data.frame(cbind(x = C3y.mixfit$x, C3y.mixfit$posterior))

# Set threshold
# I'm just going to use 0.5, because that seems least biased

# Visualize breakdown of observations
C3y.mixfit.post %>%
  mutate(label = ifelse(comp.1 > 0.5, "slow", "fast")) %>% 
  ggplot(aes(x = factor(label))) +
  geom_bar() +
  xlab("Component") +
  ylab("Number of Data Points") +
  theme_test()

# Label
C3y.mixfit.post <- C3y.mixfit.post %>%
  mutate(label = ifelse(comp.1 > 0.5, "slow", "fast")) %>%
  add_column(Soil=c(rep("C3", nrow(.))), Amendment=c(rep("Y", nrow(.)))) # add soil and amendment labels back
```


# next

* can I test between distributions using mu and sigma?

apply groups back to ASVs in unaveraged data sets
* slow vs fast proportion 
* 16S copy number in each group, hypothesis = slow has low, fast has high
* change abundance in each group, hypothesis = depends on amendment, in water control fast higher than slow, in water equal
* start time in each group, hypothesis = fast early, slow mix, probably insignicant but variation might vary (levene's test?)

