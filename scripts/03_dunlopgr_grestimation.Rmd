---
title: "Dunlop growth rates - estimate growth rates"
author: "Cassandra Wattenburger"
date: "11/15/2020"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(results = "show")
knitr::opts_chunk$set(message = FALSE)
```

**Goal of this script:** Estimate in-situ growth rates from time series.

Steps:

1. Remove 0s from dataset
2. Filter sparse time series
3. Log transform normalized abundance
4. Estimate growth rates using sliding windows
5. Filter essentially perfect fits
6. Choose "best" growth rate estimate based on smallest p-value
7. Control for false positives (simulation)
8. Calculate specific growth rate and generation time


# Import libraries

```{r}
rm(list=ls())

library("phyloseq")
library("plyr")
library("dplyr")
library("reshape2")
library("stats")
library("ggplot2")

sessionInfo()
```


# Import data and reformat

```{r}
# Import spike-in normalized data with individual taxa
load("../rdata.files/gr_microcosm.norm.tax.RData")
ucosm.norm <- microcosm.norm.tax

# Rename columns
colnames(ucosm.norm)[1:7] <- c("ASV","SampleID","Amendment","Soil","TP","Day","abund")

# Replicate info
rep <- read.csv("../metadata/replicate.metadata.csv")

# Remove Aquifex sequences (internal standard)
aqui <- filter(ucosm.norm, ucosm.norm$Genus=="Aquifex")
ucosm.norm <- ucosm.norm[!ucosm.norm$Genus %in% "Aquifex",]
asvs <- as.character(unique(ucosm.norm$ASV))

# Better sample labeling
ucosm.norm$Sample <- gsub("sa", "", ucosm.norm$SampleID)
ucosm.norm$Sample <- as.integer(ucosm.norm$Sample)
ucosm.norm <- ucosm.norm[,-2] 

# Add replicate info
ucosm.norm <- merge(ucosm.norm, rep, by="Sample", all.x=TRUE)
ucosm.norm$Rep <- as.factor(ucosm.norm$Rep)
colnames(ucosm.norm)[14] <- "Replicate"

# Create variable with metadata for subsetting later
ucosm.norm <- mutate(ucosm.norm, Label=paste0(Soil, Amendment, Replicate, ASV)) # unique identifier
```

### Remove 0s, filter sparse taxa (< 3 tps), log transform

Logic for removing zeroes:
* Cannot log transform
* Imputing values caused various issues with growth rate estimation (see growthrate_growthestimation_impute.Rmd)
* Stochasticity among taxon growth in microcosms may lead to data drop outs that removing 0s ignores, "stabilizes" the curves
* Limits the number of datapoints used for fitting the line and decreases the false positive rate by decreasing the number of estimations

Drawbacks:
* We cannot tell if the zero value was a real decrease in abundance, due to stochasticity in bacterial growth, or an artefact of sequencing depth/method

I can't fit a linear model to less than 3 data points, so we'll remove time series that don't have at least 3 time points present. Log transformation will change exponential growth into linear growth for fitting the model.

```{r}
# Remove 0s
ucosm.zero <- filter(ucosm.norm, abund > 0)

# Remove time series with < 3 tps remaining (can't fit a line)
occurences <- ucosm.zero %>% 
  group_by(Label) %>% 
  summarize(occurs = n()) %>% 
  filter(occurs > 2) %>% 
  ungroup()

ucosm.filter <- inner_join(ucosm.zero, occurences) %>% 
  select(everything(), -occurs)

# Natural log transform the data
ucosm.log <- mutate(ucosm.filter, abund.log = log(abund))
```

# Fit linear model to the data

How it works:

Employs a "sliding window" that first tries to fit points 1-3, then 1-4, then 1-5 etc. After each fit it checks that the p-value is <= 0.05 and the slope > 0. If not, it keeps going without saving the result. After checking all available points in the window without success, the loop restarts on a new window starting at point 2 (tests points 2-4, 2-5, 2-6, etc). Once an estimate that has p-value <= 0.05 and slope > 0 is found, the script checks if etending the window improves the estimate (lower p-value). As long as the p-value improves, the window extends. The script stops and saves previous estimate as soon as the estimate stops improving. This method minimizes the number of estimates made by truncating the estimation window and stopping when a good solution is found. The script will test every window even if a solution is found.

```{r}
# Save function
savefit <- function(start, end, df, output) { # Start point, end point, time series data, output dataframe
  # Save estimate info
  est <- NULL; coeff <- NULL; residuals <- NULL; pval <- NULL; length <- NULL; thisrow <- data.frame() # clear previous
  est <- lm(abund.log ~ Day, data=datasub[start:end,])
  coeff <- est$coefficients[2]
  residuals <- sum(abs(resid(est)))
  pval <- summary(est)$coefficients[2,4]
  length <- end - start + 1
  thisrow <- data.frame(label, soil, amend, asv, rep, start, end, length, coeff, pval, residuals, row.names <- NULL)
  output <- rbind(output, thisrow)
  return(output)
}

# Fit linear estimate to the data with sliding window
gr.est <- data.frame()
for (label in as.character(unique(ucosm.log$Label))) {
  # Subset one time series
  #print(paste("Subset new time series:", label))
  datasub <- data.frame()
  datasub <- ucosm.log[ucosm.log$Label==label,] # subset growth curve
  stop <- FALSE
  # Save time series info
  soil <- NULL; amend = NULL; rep = NULL; asv = NULL
  soil <- as.character(unique(datasub$Soil))
  amend <- as.character(unique(datasub$Amendment))
  rep <- as.numeric(unique(datasub$Replicate))
  asv <- as.character(unique(datasub$ASV))
  
  # Sliding window
  for (b in 1:(nrow(datasub)-2)) { # start of window
    #if (stop == TRUE) {break} this would stop the loop after the first solution is found, but we decided to consider all windows instead
    start <- b
    stop <- FALSE # this ensures all windows are considered (for each new b/window, stop is reset to false)
    #print(paste("Start:", b))
    for (e in (b+2):nrow(datasub)) { # end of window
      if (stop == TRUE) {break} # stop extending the window if a solution is found
      #print(paste("End:", e))
   
      # Fit linear model to window
      test.lm <- NULL; test.p <- NULL; test.coeff <- NULL
      test.lm <- lm(abund.log ~ Day, data=datasub[b:e,])
      test.p <- summary(test.lm)$coefficients[2,4]
      test.coeff <- test.lm$coefficients[2]
      #print(paste("Testing window. Start =", b, "End =", e, "Results: test.p =", test.p, "test.coeff =", test.coeff))

      # Extend the window
      if (test.p <= 0.05 & test.coeff > 0 & e < nrow(datasub)) { # good fit, but more data might improve?
        #print(paste("TRUE: test.p <= 0.05 & test.coeff > 0 & e < 15", "Pval =", test.p, "Coeff =", test.coeff, "End =", e))
        for (x in ((e+1):nrow(datasub))) { # extend this window to see if it improves
          if (stop == TRUE) {break} # stop extending if the solution improves or if hit end of time series
          #print(paste("Extending window. Start =", b, "End =", x))
          testprev.lm <- NULL; testprev.p <- NULL; testprev.coeff <- NULL; testnew.lm <- NULL; testnew.p <- NULL; testnew.coeff <- NULL
          testprev.lm <- lm(abund.log ~ Day, data=datasub[b:(x-1),])
          testprev.p <- summary(testprev.lm)$coefficients[2,4]
          testprev.coeff <- testprev.lm$coefficients[2]
          testnew.lm <- lm(abund.log ~ Day, data=datasub[b:x,])
          testnew.p <- summary(testnew.lm)$coefficients[2,4]
          testnew.coeff <- testnew.lm$coefficients[2]
          
          # Continue extending the window
          if (testnew.p <= testprev.p & testnew.coeff > 0 & x < nrow(datasub)) { # if adding data improved (or didn't hurt) the estimate, keep extending
            #print(paste("TRUE: testnew.p <= testprev.p & testnew.coeff > 0 & x < 15...", "testnew.p =", testnew.p, "testprev.p =", testprev.p, "testnew.coeff =", testnew.coeff, "EndX =", x))
            next
          }
          
          # No improvement
          else if (testnew.p > testprev.p & testprev.coeff > 0 & x < nrow(datasub)) { # if adding data did not improve the estimate, stop
            #print(paste("TRUE: testnew.p > testprev.p & testprev.coeff > 0 & x < 15... testnew.p =", testnew.p, "testprev.p =", testprev.p, "testprev.coeff =", testprev.coeff, "EndX =", x))
            end <- x-1
            gr.est <- savefit(start, end, datasub, gr.est)
            #print(paste("Saved previous result. Start:", start, "End:", e))
            stop <- TRUE
          }
          
          # No more data pts to fit
          else if (testnew.p <= testprev.p & testnew.coeff > 0 & x == nrow(datasub)) { # improved but no more data
            #print(paste("TRUE: testnew.p <= testprev.p & testnew.coeff > 0 & x == 15... testnew.p =", testnew.p, "testprev.p =", testprev.p, "testnew.coeff =", testnew.coeff, "EndX =", x))
            end <- x
            gr.est <- savefit(start, end, datasub, gr.est)
            #print(paste("Saved current result. Start:", start, "End:", e))
            stop <- TRUE
          } 
        }
      }
      
      # No more data pts to fit
      else if (test.p <= 0.05 & test.coeff > 0 & e==nrow(datasub)) { # meets threshold but no remaining points to extend
        #print(paste("TRUE: test.p <= 0.05 & test.coeff > 0 & e==15...", "test.p =", test.p, "test.coeff =", test.coeff, "EndE =", e))
        end <- e
        gr.est <- savefit(start, end, datasub, gr.est)
        #print(paste("Saved current result. Start:", start, "End:", e))
        stop <- TRUE
      }
    }
  }
}
colnames(gr.est) <- c("label","Soil","Amendment","ASV","Replicate","Start","End","Length","Slope","Pvalue", "Residuals")
```

# Remove "essentially perfect fits"

I can't find any guidance on how to determine whether or not a fit is "perfect" but I know that the residuals are essentially equally to 0 for perfect fits. I'll use 0.0001 as a filtering threshold for removal.

```{r}
# Remove "perfect" fits as precaution
gr.noperf <- filter(gr.est, Residuals >= 0.0001)
nrow(gr.est)
nrow(gr.noperf)
```

# Select best fit for each time series

* Smallest slope p-value

```{r}
# Best p-value for each curve
gr.best <- data.frame()
for (l in as.character(unique(gr.noperf$label))) {
  datasub <- gr.noperf[gr.noperf$label==l,]
  pmin <- min(datasub$Pvalue)
  hold = datasub[datasub$Pvalue==pmin,]
  gr.best <- rbind(gr.best, hold)
}
nrow(gr.noperf)
nrow(gr.best)
```

Note: previously tried using smallest residual as selection criteria but it results in a uniform p-value distribution.

# Estimation filter: False positive control

### Simulate random data

Completely random data designed to reflect actual data, if we detect "significant" growth rate estimates from this, we must control for that, because the same thing can happen in our actual data.

Information about real dataset to use for simulating random data:

```{r, results="show"}
# Minimum and maximum values to base simulated data on
low <- min(ucosm.log$abund.log)
hi <- max(ucosm.log$abund.log)

# How many points do curves generally have? drop outs are common due to 0s
length.df <- data.frame()
for (l in as.character(unique(ucosm.log$Label))) {
  datasub <- ucosm.log[ucosm.log$Label==l,]
  num <- nrow(datasub)
  day <- mean(datasub$Day)
  thisrow <- data.frame(l, num, day)
  length.df <- rbind(length.df, thisrow)
}

num.avg <- mean(length.df$num)
day.avg <- mean(length.df$day)

ggplot(length.df, aes(x=NA, y=num)) +
  geom_boxplot() +
  geom_jitter(alpha=0.02) +
  theme_test() +
  labs(title="Actual data", x="", y="Number of data pts")

ggplot(length.df, aes(x=NA, y=day)) +
  geom_boxplot() +
  geom_jitter(alpha=0.02) +
  theme_test() +
  labs(title="Actual data", x="", y="Average day present")
```

Simulate random data points, 1000 times:

```{r}
# Simulate time series
set.seed(101)
tps <- c(0, 0.333, 0.667, 1, 1.5, 2, 3, 5, 7, 9, 13, 17, 21, 28, 50)
sim.data <- data.frame()
for (i in 1:1000) { # number of randomly generated growth curves
  thisrow <- data.frame()
  randabund <- NULL
  hold <- NULL
  randpts <- ceiling(runif(1, min=2, max=15)) # randomly choose number of pts between 3 and 15
  randabund <- runif(randpts, min = low, max = hi) # randomly generate abundance values within range
  randdays <- sort(sample(tps, size=randpts, replace=FALSE)) # randomly assign days from list
  hold <- cbind(rep(i, randpts),randdays, randabund)
  sim.data= rbind(sim.data, hold)
}
colnames(sim.data)[1] <- "sim"

sim.melt <- melt(sim.data, id.vars=c("sim"))
sim.summary <- ddply(sim.melt[sim.melt$variable=="randdays",], c("sim"), summarize, len=length(value), avg=mean(value))

ggplot(sim.summary, aes(x=NA, y=len)) +
  geom_boxplot() +
  geom_jitter(alpha=0.025) +
  theme_test() +
  labs(title="Simulated data", x="", y="Number of data pts")

ggplot(sim.summary, aes(x=NA, y=avg)) +
  geom_boxplot() +
  geom_jitter(alpha=0.025) +
  theme_test() +
  labs(title="Simulated data", x="", y="Average day present")
```

The simulated data is weighted towards having more data pts per time series and having those data points present at later time points. For now, I'm inclined to make fewer assumptions and go forward with using the completely randomly generated data instead of trying to weight the points. I don't think that the day the pts are present on will matter much. That the simulated data set will have more pts to fit just means we will overestimate the number of false positives, giving us more conservative thresholds for the real data than what is predicted, which is better than underestimating.

Plot some of the random time series:

```{r, results="show"}
ggplot(sim.data[sim.data$sim=="1",], aes(x=randdays, y=randabund)) +
  geom_point() +
  geom_line() +
  theme_test() +
  labs(x="Day", y="random abundance")

ggplot(sim.data[sim.data$sim=="3",], aes(x=randdays, y=randabund)) +
  geom_point() +
  geom_line() +
  theme_test() +
  labs(x="Day", y="random abundance")

ggplot(sim.data[sim.data$sim=="10",], aes(x=randdays, y=randabund)) +
  geom_point() +
  geom_line() +
  theme_test() +
  labs(x="Day", y="random abundance")

ggplot(sim.data[sim.data$sim=="55",], aes(x=randdays, y=randabund)) +
  geom_point() +
  geom_line() +
  theme_test() +
  labs(x="Day", y="random abundance")

ggplot(sim.data[sim.data$sim=="100",], aes(x=randdays, y=randabund)) +
  geom_point() +
  geom_line() +
  theme_test() +
  labs(x="Day", y="random abundance")
```

Well, these look disturbingly like actual data. That's why we're doing this I suppose.

### Estimate growth rates on simulated data

Small modifications in for loop to accomodate simulated data (noted in chunk).

```{r}
# Save function
savefit.sim <- function(start, end, df, output) { # Start point, end point, time series data, output dataframe
  # Save estimate info
  est <- NULL; coeff <- NULL; residuals <- NULL; pval <- NULL; length <- NULL; thisrow <- data.frame() # clear previous
  est <- lm(randabund ~ randdays, data=datasub[start:end,]) # variables altered to match simulated data columns
  coeff <- est$coefficients[2]
  residuals <- sum(abs(resid(est)))
  pval <- summary(est)$coefficients[2,4]
  length <- end - start + 1
  thisrow <- data.frame(sim, start, end, length, coeff, pval, residuals, row.names <- NULL) # altered line, don't need treatment metadata
  output <- rbind(output, thisrow)
  return(output)
}

# Fit linear estimate to the data with sliding window
sim.est <- data.frame()
for (sim in as.character(unique(sim.data$sim))) { # variables altered
  # Subset one time series
  #print(paste("Subset new time series:", sim))
  datasub <- data.frame()
  datasub <- sim.data[sim.data$sim==sim,] # subset growth curve # variables altered
  stop <- FALSE
  # Save time series ##not needed##
  #soil <- NULL; amend <- NULL; rep <- NULL; asv <- NULL
  #soil <- as.character(unique(datasub$Soil))
  #amend <- as.character(unique(datasub$Amendment))
  #rep <- as.numeric(unique(datasub$Replicate))
  #asv <- as.character(unique(datasub$ASV))
  
  # Sliding window
  for (b in 1:(nrow(datasub)-2)) { # start of window
    #if (stop == TRUE) {break} this would stop the loop after the first solution is found, but we decided to consider all windows instead
    start <- b
    stop <- FALSE # this ensures all windows are considered (for each new b/window, stop is reset to false)
    #print(paste("Start:", b))
    for (e in (b+2):nrow(datasub)) { # end of window
      if (stop == TRUE) {break} # stop extending the window if a solution is found
      #print(paste("End:", e))
   
      # Fit linear model to window
      test.lm <- NULL; test.p <- NULL; test.coeff <- NULL
      test.lm <- lm(randabund ~ randdays, data=datasub[b:e,]) # variables altered
      test.p <- summary(test.lm)$coefficients[2,4]
      test.coeff <- test.lm$coefficients[2]
      #print(paste("Testing window. Start =", b, "End =", e, "Results: test.p =", test.p, "test.coeff =", test.coeff))

      # Extend the window
      if (test.p <= 0.05 & test.coeff > 0 & e < nrow(datasub)) { # good fit, but more data might improve?
        #print(paste("TRUE: test.p <= 0.05 & test.coeff > 0 & e < 15", "Pval =", test.p, "Coeff =", test.coeff, "End =", e))
        for (x in ((e+1):nrow(datasub))) { # extend this window to see if it improves
          if (stop == TRUE) {break} # stop extending if the solution improves or if hit end of time series
          #print(paste("Extending window. Start =", b, "End =", x))
          testprev.lm <- NULL; testprev.p <- NULL; testprev.coeff <- NULL; testnew.lm <- NULL; testnew.p <- NULL; testnew.coeff <- NULL
          testprev.lm <- lm(randabund ~ randdays, data=datasub[b:(x-1),]) # variables altered
          testprev.p <- summary(testprev.lm)$coefficients[2,4]
          testprev.coeff <- testprev.lm$coefficients[2]
          testnew.lm <- lm(randabund ~ randdays, data=datasub[b:x,]) # variables altered
          testnew.p <- summary(testnew.lm)$coefficients[2,4]
          testnew.coeff <- testnew.lm$coefficients[2]
          
          # Continue extending the window
          if (testnew.p <= testprev.p & testnew.coeff > 0 & x < nrow(datasub)) { # if adding data improved (or didn't hurt) the estimate, keep extending
            #print(paste("TRUE: testnew.p <= testprev.p & testnew.coeff > 0 & x < 15...", "testnew.p =", testnew.p, "testprev.p =", testprev.p, "testnew.coeff =", testnew.coeff, "EndX =", x))
            next
          }
          
          # No improvement
          else if (testnew.p > testprev.p & testprev.coeff > 0 & x < nrow(datasub)) { # if adding data did not improve the estimate, stop
            #print(paste("TRUE: testnew.p > testprev.p & testprev.coeff > 0 & x < 15... testnew.p =", testnew.p, "testprev.p =", testprev.p, "testprev.coeff =", testprev.coeff, "EndX =", x))
            end <- x-1
            sim.est <- savefit(start, end, datasub, sim.est)
            #print(paste("Saved previous result. Start:", start, "End:", e))
            stop <- TRUE
          }
          
          # No more data pts to fit
          else if (testnew.p <= testprev.p & testnew.coeff > 0 & x == nrow(datasub)) { # improved but no more data
            #print(paste("TRUE: testnew.p <= testprev.p & testnew.coeff > 0 & x == 15... testnew.p =", testnew.p, "testprev.p =", testprev.p, "testnew.coeff =", testnew.coeff, "EndX =", x))
            end <- x
            sim.est <- savefit(start, end, datasub, sim.est)
            #print(paste("Saved current result. Start:", start, "End:", e))
            stop <- TRUE
          } 
        }
      }
      
      # No more data pts to fit
      else if (test.p <= 0.05 & test.coeff > 0 & e==nrow(datasub)) { # meets threshold but no remaining points to extend
        #print(paste("TRUE: test.p <= 0.05 & test.coeff > 0 & e==15...", "test.p =", test.p, "test.coeff =", test.coeff, "EndE =", e))
        end <- e
        sim.est <- savefit.sim(start, end, datasub, sim.est)
        #print(paste("Saved current result. Start:", start, "End:", e))
        stop <- TRUE
      }
    }
  }
}
```

Filter essentially perfect fits and choose best estimate.

Same method as in growthrate_growthestimation_rm0.Rmd

```{r}
# Remove essentially perfect fits
sim.noperf <- filter(sim.est, residuals >= 0.0001)

# Choose best window (lowest p-value)
sim.best <- data.frame()
for (i in as.character(unique(sim.noperf$sim))) {
  datasub <- sim.noperf[sim.noperf$sim==i,]
  pmin <- min(datasub$pval)
  hold <- datasub[datasub$pval==pmin,]
  sim.best <- rbind(sim.best, hold)
}
```

False positive rates:

```{r}
# False positives
a <- nrow(sim.best[sim.best$pval <= 0.05,])
b <- nrow(sim.best[sim.best$pval <= 0.025,])
c <- nrow(sim.best[sim.best$pval <= 0.01,])
d <- nrow(sim.best[sim.best$pval <= 0.005,])
e <- nrow(sim.best[sim.best$pval <= 0.001,])
f <- nrow(sim.best[sim.best$pval <= 0.0005,])

false.df <- data.frame(c(0.05, 0.025, 0.01, 0.005, 0.001, 0.0005), c(a,b,c,d,e,f))
colnames(false.df)=c("pvalue","false")

ggplot(false.df, aes(x=pvalue, y=false)) +
  geom_point() +
  theme_test() +
  labs(title="Relationship between p-value and number of false positives", x="P-value", y="False positives")
```

10%, 5%, 2.5%, 1% false positive p-value thresholds:

```{r}
# Pvalue thresholds for false positive rates:
nrow(sim.best[sim.best$pval <= 0.013,]) # ~10%, 100/1000
nrow(sim.best[sim.best$pval <= 0.01,]) # ~7.5%, 75/100
nrow(sim.best[sim.best$pval <= 0.0069,]) # ~5%, 50/1000
nrow(sim.best[sim.best$pval <= 0.0027,]) # ~2.5%, 25/1000
nrow(sim.best[sim.best$pval <= 0.0009,]) # ~1%, 10/1000
```

False positive thresholds:
* 10%: P-value=0.013 (100/1000)
* 5%: P-value=0.0069 (50/1000)
* 2.5%: P-value=0.0027 (25/1000)
* 1%: P-value=0.0009 (10/1000)

I chose a permutation apporach over a false dicovery rate correction method like Benjamini-Hochberg or q-value estimation because of the way this data was generated. I know a vast majority of the estimations I conducted are junk, so I placed filtering thresholds on those to counter-act that. However, the truncated p-value distribution also means that common false-positive control methods won't work properly, because they expect to see a range of p-values from 0 to 1.

Histogram of quality filtered p-values:

```{r}
hist(gr.best$Pvalue, xlab="P-values", main="Histogram of quality filtered p-values")
```

This p-value distribution is anti-conservative  based on the trailing right tail (this is a good thing). However, it appears that there must be some proportion of false positives based on how high that right tail is compared to the initial spike at the beginning of the distribution. We must do some form of multiple comparison control.

See: http://varianceexplained.org/statistics/interpreting-pvalue-histogram/

Filter p-values based on cut-offs determined (10%, 5%, 2.5%, 1%):

```{r, restuls="show"}
# ~10% false positives
gr.falsepos10 <- subset(gr.best, Pvalue <= 0.013)
nrow(gr.falsepos10 )

# ~5% false positives
gr.falsepos5 <- subset(gr.best, Pvalue <= 0.0069)
nrow(gr.falsepos5)

# 2.5%
gr.falsepos2.5 <- subset(gr.best, Pvalue <= 0.0027)
nrow(gr.falsepos2.5)

# 1%
gr.falsepos1 <- subset(gr.best, Pvalue <= 0.0009)
nrow(gr.falsepos1)
```

2.5% and 1% seem too conservative and remove most estimates. Let's see how 10% and 5% look.

10% false positive rate:

```{r}
# Select replicated time series
rep10.list <- list()
for (s in as.character(unique(gr.falsepos10$Soil))) {
  for (c in as.character(unique(gr.falsepos10[gr.falsepos10$Soil==s,]$Amendment))) {
    for (a in as.character(unique(gr.falsepos10[gr.falsepos10$Soil==s & gr.falsepos10$Amendment==c,]$ASV))) {
        timeseries <- as.character(gr.falsepos10[gr.falsepos10$Soil==s & gr.falsepos10$Amendment==c & gr.falsepos10$ASV==a,]$label)
        if (length(timeseries) > 1) {
          rep10.list <- append(rep10.list, timeseries)
        }
    }
  }
}
gr.rep10 <- filter(gr.falsepos10, label %in% rep10.list)
```

```{r, results="show"}
# Randomly select 10 time series to check
set.seed(310)
gr.rep10 <- mutate(gr.rep10, Treatment=paste0(Soil, Amendment, ASV))
rand <- sample(as.character(unique(gr.rep10$Treatment)), 10)

# 1 
reps101 <- gr.rep10[gr.rep10$Treatment==rand[1],]
reps101.df <- ucosm.log[ucosm.log$ASV==as.character(unique(reps101$ASV)) & ucosm.log$Soil==as.character(unique(reps101$Soil)) & ucosm.log$Amendment==as.character(unique(reps101$Amendment)) & ucosm.log$Replicate %in% as.numeric(reps101$Replicate),]

ggplot(reps101.df, aes(x=Day, y=abund.log, shape=Replicate)) +
  geom_point() +
  geom_line() +
  geom_smooth(method="lm", data=reps101.df[reps101.df$Replicate==as.numeric(reps101$Replicate)[1],][as.numeric(reps101[reps101$Replicate==as.numeric(reps101$Replicate[1]),]$Start):as.numeric(reps101[reps101$Replicate==as.numeric(reps101$Replicate[1]),]$End),], linetype=2, color="red", alpha=0.10, fill="grey") +
  geom_smooth(method="lm", data=reps101.df[reps101.df$Replicate==as.numeric(reps101$Replicate)[2],][as.numeric(reps101[reps101$Replicate==as.numeric(reps101$Replicate[2]),]$Start):as.numeric(reps101[reps101$Replicate==as.numeric(reps101$Replicate[2]),]$End),], linetype=2, color="blue", alpha=0.10, fill="grey") +
    geom_smooth(method="lm", data=reps101.df[reps101.df$Replicate==as.numeric(reps101$Replicate)[3],][as.numeric(reps101[reps101$Replicate==as.numeric(reps101$Replicate[3]),]$Start):as.numeric(reps101[reps101$Replicate==as.numeric(reps101$Replicate[3]),]$End),], linetype=2, color="green", alpha=0.10, fill="grey") +
  theme_test() +
  labs(title=paste("1.", reps101$Soil, reps101$Amendment, reps101$ASV))

# 2 
reps102 <- gr.rep10[gr.rep10$Treatment==rand[2],]
reps102.df <- ucosm.log[ucosm.log$ASV==unique(as.character(reps102$ASV)) & ucosm.log$Soil==unique(as.character(reps102$Soil)) & ucosm.log$Amendment==unique(as.character(reps102$Amendment)) & ucosm.log$Replicate %in% as.numeric(unique(reps102$Replicate)),]

ggplot(reps102.df, aes(x=Day, y=abund.log, shape=Replicate)) +
  geom_point() +
  geom_line() +
  geom_smooth(method="lm", data=reps102.df[reps102.df$Replicate==as.numeric(reps102$Replicate)[1],][as.numeric(reps102[reps102$Replicate==as.numeric(reps102$Replicate[1]),]$Start):as.numeric(reps102[reps102$Replicate==as.numeric(reps102$Replicate[1]),]$End),], linetype=2, color="red", alpha=0.10, fill="grey") +
  geom_smooth(method="lm", data=reps102.df[reps102.df$Replicate==as.numeric(reps102$Replicate)[2],][as.numeric(reps102[reps102$Replicate==as.numeric(reps102$Replicate[2]),]$Start):as.numeric(reps102[reps102$Replicate==as.numeric(reps102$Replicate[2]),]$End),], linetype=2, color="blue", alpha=0.10, fill="grey") +
  theme_test() +
  labs(title=paste("2.", reps102$Soil, reps102$Amendment, reps102$ASV))

# 3
reps103 <- gr.rep10[gr.rep10$Treatment==rand[3],]
reps103.df <- ucosm.log[ucosm.log$ASV==unique(as.character(reps103$ASV)) & ucosm.log$Soil==unique(as.character(reps103$Soil)) & ucosm.log$Amendment==unique(as.character(reps103$Amendment)) & ucosm.log$Replicate %in% as.numeric(unique(reps103$Replicate)),]

ggplot(reps103.df, aes(x=Day, y=abund.log, shape=Replicate)) +
  geom_point() +
  geom_line() +
  geom_smooth(method="lm", data=reps103.df[reps103.df$Replicate==as.numeric(reps103$Replicate)[1],][as.numeric(reps103[reps103$Replicate==as.numeric(reps103$Replicate[1]),]$Start):as.numeric(reps103[reps103$Replicate==as.numeric(reps103$Replicate[1]),]$End),], linetype=2, color="red", alpha=0.10, fill="grey") +
  geom_smooth(method="lm", data=reps103.df[reps103.df$Replicate==as.numeric(reps103$Replicate)[2],][as.numeric(reps103[reps103$Replicate==as.numeric(reps103$Replicate[2]),]$Start):as.numeric(reps103[reps103$Replicate==as.numeric(reps103$Replicate[2]),]$End),], linetype=2, color="blue", alpha=0.10, fill="grey") +
    geom_smooth(method="lm", data=reps101.df[reps101.df$Replicate==as.numeric(reps101$Replicate)[3],][as.numeric(reps101[reps101$Replicate==as.numeric(reps101$Replicate[3]),]$Start):as.numeric(reps101[reps101$Replicate==as.numeric(reps101$Replicate[3]),]$End),], linetype=2, color="green", alpha=0.10, fill="grey") +
  theme_test() +
  labs(title=paste("3.", reps103$Soil, reps103$Amendment, reps103$ASV))

# 4
reps104 <- gr.rep10[gr.rep10$Treatment==rand[4],]
reps104.df <- ucosm.log[ucosm.log$ASV==unique(as.character(reps104$ASV)) & ucosm.log$Soil==unique(as.character(reps104$Soil)) & ucosm.log$Amendment==unique(as.character(reps104$Amendment)) & ucosm.log$Replicate %in% as.numeric(unique(reps104$Replicate)),]

ggplot(reps104.df, aes(x=Day, y=abund.log, shape=Replicate)) +
  geom_point() +
  geom_line() +
  geom_smooth(method="lm", data=reps104.df[reps104.df$Replicate==as.numeric(reps104$Replicate)[1],][as.numeric(reps104[reps104$Replicate==as.numeric(reps104$Replicate[1]),]$Start):as.numeric(reps104[reps104$Replicate==as.numeric(reps104$Replicate[1]),]$End),], linetype=2, color="red", alpha=0.10, fill="grey") +
  geom_smooth(method="lm", data=reps104.df[reps104.df$Replicate==as.numeric(reps104$Replicate)[2],][as.numeric(reps104[reps104$Replicate==as.numeric(reps104$Replicate[2]),]$Start):as.numeric(reps104[reps104$Replicate==as.numeric(reps104$Replicate[2]),]$End),], linetype=2, color="blue", alpha=0.10, fill="grey") +
  theme_test() +
  geom_smooth(method="lm", data=reps101.df[reps101.df$Replicate==as.numeric(reps101$Replicate)[3],][as.numeric(reps101[reps101$Replicate==as.numeric(reps101$Replicate[3]),]$Start):as.numeric(reps101[reps101$Replicate==as.numeric(reps101$Replicate[3]),]$End),], linetype=2, color="green", alpha=0.10, fill="grey") +
  labs(title=paste("4.", reps104$Soil, reps104$Amendment, reps104$ASV))

# 5
reps105 <- gr.rep10[gr.rep10$Treatment==rand[10],]
reps105.df <- ucosm.log[ucosm.log$ASV==unique(as.character(reps105$ASV)) & ucosm.log$Soil==unique(as.character(reps105$Soil)) & ucosm.log$Amendment==unique(as.character(reps105$Amendment)) & ucosm.log$Replicate %in% as.numeric(unique(reps105$Replicate)),]

ggplot(reps105.df, aes(x=Day, y=abund.log, shape=Replicate)) +
  geom_point() +
  geom_line() +
  geom_smooth(method="lm", data=reps105.df[reps105.df$Replicate==as.numeric(reps105$Replicate)[1],][as.numeric(reps105[reps105$Replicate==as.numeric(reps105$Replicate[1]),]$Start):as.numeric(reps105[reps105$Replicate==as.numeric(reps105$Replicate[1]),]$End),], linetype=2, color="red", alpha=0.10, fill="grey") +
  geom_smooth(method="lm", data=reps105.df[reps105.df$Replicate==as.numeric(reps105$Replicate)[2],][as.numeric(reps105[reps105$Replicate==as.numeric(reps105$Replicate[2]),]$Start):as.numeric(reps105[reps105$Replicate==as.numeric(reps105$Replicate[2]),]$End),], linetype=2, color="blue", alpha=0.10, fill="grey") +
  theme_test() +
  labs(title=paste("10.", reps105$Soil, reps105$Amendment, reps105$ASV))
```

5% false positive rate:

```{r}
# Select replicated time series
rep5.list <- list()
for (s in as.character(unique(gr.falsepos5$Soil))) {
  for (c in as.character(unique(gr.falsepos5[gr.falsepos5$Soil==s,]$Amendment))) {
    for (a in as.character(unique(gr.falsepos5[gr.falsepos5$Soil==s & gr.falsepos5$Amendment==c,]$ASV))) {
        timeseries <- as.character(gr.falsepos5[gr.falsepos5$Soil==s & gr.falsepos5$Amendment==c & gr.falsepos5$ASV==a,]$label)
        if (length(timeseries) > 1) {
          rep5.list <- append(rep5.list, timeseries)
        }
    }
  }
}
gr.rep5 <- filter(gr.falsepos5, label %in% rep5.list)
```

```{r, results="show"}
# Randomly select 10 time series to check
set.seed(310)
gr.rep5 <- mutate(gr.rep5, Treatment=paste0(Soil, Amendment, ASV))
rand <- sample(as.character(unique(gr.rep5$Treatment)), 10)

# 1 
reps51 <- gr.rep5[gr.rep5$Treatment==rand[1],]
reps51.df <- ucosm.log[ucosm.log$ASV==as.character(unique(reps51$ASV)) & ucosm.log$Soil==as.character(unique(reps51$Soil)) & ucosm.log$Amendment==as.character(unique(reps51$Amendment)) & ucosm.log$Replicate %in% as.numeric(reps51$Replicate),]

ggplot(reps51.df, aes(x=Day, y=abund.log, shape=Replicate)) +
  geom_point() +
  geom_line() +
  geom_smooth(method="lm", data=reps51.df[reps51.df$Replicate==as.numeric(reps51$Replicate)[1],][as.numeric(reps51[reps51$Replicate==as.numeric(reps51$Replicate[1]),]$Start):as.numeric(reps51[reps51$Replicate==as.numeric(reps51$Replicate[1]),]$End),], linetype=2, color="red", alpha=0.10, fill="grey") +
  geom_smooth(method="lm", data=reps51.df[reps51.df$Replicate==as.numeric(reps51$Replicate)[2],][as.numeric(reps51[reps51$Replicate==as.numeric(reps51$Replicate[2]),]$Start):as.numeric(reps51[reps51$Replicate==as.numeric(reps51$Replicate[2]),]$End),], linetype=2, color="blue", alpha=0.10, fill="grey") +
  labs(title=paste("1.", reps51$Soil, reps51$Amendment, reps51$ASV)) +
  theme_test()

# 2 
reps52 <- gr.rep5[gr.rep5$Treatment==rand[2],]
reps52.df <- ucosm.log[ucosm.log$ASV==unique(as.character(reps52$ASV)) & ucosm.log$Soil==unique(as.character(reps52$Soil)) & ucosm.log$Amendment==unique(as.character(reps52$Amendment)) & ucosm.log$Replicate %in% as.numeric(unique(reps52$Replicate)),]

ggplot(reps52.df, aes(x=Day, y=abund.log, shape=Replicate)) +
  geom_point() +
  geom_line() +
  geom_smooth(method="lm", data=reps52.df[reps52.df$Replicate==as.numeric(reps52$Replicate)[1],][as.numeric(reps52[reps52$Replicate==as.numeric(reps52$Replicate[1]),]$Start):as.numeric(reps52[reps52$Replicate==as.numeric(reps52$Replicate[1]),]$End),], linetype=2, color="red", alpha=0.10, fill="grey") +
  geom_smooth(method="lm", data=reps52.df[reps52.df$Replicate==as.numeric(reps52$Replicate)[2],][as.numeric(reps52[reps52$Replicate==as.numeric(reps52$Replicate[2]),]$Start):as.numeric(reps52[reps52$Replicate==as.numeric(reps52$Replicate[2]),]$End),], linetype=2, color="blue", alpha=0.10, fill="grey") +
  theme_test() +
  labs(title=paste("2.", reps52$Soil, reps52$Amendment, reps52$ASV))

# 3
reps53 <- gr.rep5[gr.rep5$Treatment==rand[3],]
reps53.df <- ucosm.log[ucosm.log$ASV==unique(as.character(reps53$ASV)) & ucosm.log$Soil==unique(as.character(reps53$Soil)) & ucosm.log$Amendment==unique(as.character(reps53$Amendment)) & ucosm.log$Replicate %in% as.numeric(unique(reps53$Replicate)),]

ggplot(reps53.df, aes(x=Day, y=abund.log, shape=Replicate)) +
  geom_point() +
  geom_line() +
  geom_smooth(method="lm", data=reps53.df[reps53.df$Replicate==as.numeric(reps53$Replicate)[1],][as.numeric(reps53[reps53$Replicate==as.numeric(reps53$Replicate[1]),]$Start):as.numeric(reps53[reps53$Replicate==as.numeric(reps53$Replicate[1]),]$End),], linetype=2, color="red", alpha=0.10, fill="grey") +
  geom_smooth(method="lm", data=reps53.df[reps53.df$Replicate==as.numeric(reps53$Replicate)[2],][as.numeric(reps53[reps53$Replicate==as.numeric(reps53$Replicate[2]),]$Start):as.numeric(reps53[reps53$Replicate==as.numeric(reps53$Replicate[2]),]$End),], linetype=2, color="blue", alpha=0.10, fill="grey") +
  theme_test() +
  labs(title=paste("3.", reps53$Soil, reps53$Amendment, reps53$ASV))

# 4
reps54 <- gr.rep5[gr.rep5$Treatment==rand[4],]
reps54.df <- ucosm.log[ucosm.log$ASV==unique(as.character(reps54$ASV)) & ucosm.log$Soil==unique(as.character(reps54$Soil)) & ucosm.log$Amendment==unique(as.character(reps54$Amendment)) & ucosm.log$Replicate %in% as.numeric(unique(reps54$Replicate)),]

ggplot(reps54.df, aes(x=Day, y=abund.log, shape=Replicate)) +
  geom_point() +
  geom_line() +
  geom_smooth(method="lm", data=reps54.df[reps54.df$Replicate==as.numeric(reps54$Replicate)[1],][as.numeric(reps54[reps54$Replicate==as.numeric(reps54$Replicate[1]),]$Start):as.numeric(reps54[reps54$Replicate==as.numeric(reps54$Replicate[1]),]$End),], linetype=2, color="red", alpha=0.10, fill="grey") +
  geom_smooth(method="lm", data=reps54.df[reps54.df$Replicate==as.numeric(reps54$Replicate)[2],][as.numeric(reps54[reps54$Replicate==as.numeric(reps54$Replicate[2]),]$Start):as.numeric(reps54[reps54$Replicate==as.numeric(reps54$Replicate[2]),]$End),], linetype=2, color="blue", alpha=0.10, fill="grey") +
  theme_test() +
  labs(title=paste("4.", reps54$Soil, reps54$Amendment, reps54$ASV))

# 5
reps55 <- gr.rep5[gr.rep5$Treatment==rand[10],]
reps55.df <- ucosm.log[ucosm.log$ASV==unique(as.character(reps55$ASV)) & ucosm.log$Soil==unique(as.character(reps55$Soil)) & ucosm.log$Amendment==unique(as.character(reps55$Amendment)) & ucosm.log$Replicate %in% as.numeric(unique(reps55$Replicate)),]

ggplot(reps55.df, aes(x=Day, y=abund.log, shape=Replicate)) +
  geom_point() +
  geom_line() +
  geom_smooth(method="lm", data=reps55.df[reps55.df$Replicate==as.numeric(reps55$Replicate)[1],][as.numeric(reps55[reps55$Replicate==as.numeric(reps55$Replicate[1]),]$Start):as.numeric(reps55[reps55$Replicate==as.numeric(reps55$Replicate[1]),]$End),], linetype=2, color="red", alpha=0.10, fill="grey") +
  geom_smooth(method="lm", data=reps55.df[reps55.df$Replicate==as.numeric(reps55$Replicate)[2],][as.numeric(reps55[reps55$Replicate==as.numeric(reps55$Replicate[2]),]$Start):as.numeric(reps55[reps55$Replicate==as.numeric(reps55$Replicate[2]),]$End),], linetype=2, color="blue", alpha=0.10, fill="grey") +
  theme_test() +
  labs(title=paste("5.", reps55$Soil, reps55$Amendment, reps55$ASV))

```

I'm happier with the 5% false positive rate data.

# Calculate specific growth rate (k):

Steps:

* Use estimated slope from growth curves to simulate growth over a time interval
* Use simulated abundances to solve for k

Using estimates filtered at 5% false positives.

Formula: k=(log10(b)-log10(B))*2.303/t

Where k is specific growth rate, B is abundance at beginning, b is abundance at end, and t is the time interval.

I found this guide helpful: http://web.archive.org/web/20200704105815/http://miller-lab.net/MillerLab/protocols/general-bacteriology/calculating-growth-rate/

```{r}
# Generate abundances over time interval based on estimated slope
k.df <- data.frame()
B=1 # Start with one bacteria
for (s in as.character(unique(gr.falsepos5$Soil))) {
  for (c in as.character(unique(gr.falsepos5[gr.falsepos5$Soil==s,]$Amendment))) {
    for (r in as.character(unique(gr.falsepos5[gr.falsepos5$Soil==s & gr.falsepos5$Amendment==c,]$Replicate))) {
      for (a in as.character(unique(gr.falsepos5[gr.falsepos5$Soil==s & gr.falsepos5$Amendment==c & gr.falsepos5$Replicate==r,]$ASV))) {
        datadf=data.frame() # reset to avoid duplicates
        slope=NULL
        b=NULL
        k=NULL
        datadf=gr.falsepos5[gr.falsepos5$Soil==s & gr.falsepos5$Amendment==c & gr.falsepos5$Replicate==r & gr.falsepos5$ASV==a,]
        slope=datadf$Slope
        b=(slope*3)+1 # abundance three days later
        k=(log10(b)-log10(B))*(2.303/3) # calculate k
        thisrow=cbind(datadf, k)
        k.df=rbind(k.df, thisrow)
      }
    }
  }
}
```

# Calculate doubling time

Formula: g = ln2/k

Where g is generation or doubling time and k is specific growth rate (per day).

```{r}
# Calculate doubling time based on k
g.df <- data.frame()
for (s in as.character(unique(k.df$Soil))) {
  for (c in as.character(unique(k.df[k.df$Soil==s,]$Amendment))) {
    for (r in as.character(unique(k.df[k.df$Soil==s & k.df$Amendment==c,]$Replicate))) {
      for (a in as.character(unique(k.df[k.df$Soil==s & k.df$Amend==c & k.df$Replicate==r,]$ASV))) {
        data <- data.frame()
        g <- NULL
        k <- NULL
        datadf=k.df[k.df$Soil==s & k.df$Amendment==c & k.df$Replicate==r & k.df$ASV==a,]
        k <- datadf$k
        g <- log(2)/k
        thisrow <- cbind(datadf, g)
        g.df <- rbind(g.df, thisrow)
      }
    }
  }
}
gr.final <- g.df
```

```{r, eval = FALSE}
saveRDS(gr.final, file="rdata.files/gr_gr.final_rm0.rds")
```

```{r, eval=FALSE}
# Save normalized abundance data for estimated taxa
# This is a mess, but it's my mess
library(tidyverse)

gr.final <- readRDS("../rdata.files/gr_gr.final_rm0.rds") %>% 
  rename(Label=label)

norm_estimated <- semi_join(ucosm.log, gr.final, by="Label") %>% 
  select(Label, Soil, Amendment, Day, Replicate, ASV, Domain:Genus, norm_abund=abund)

saveRDS(norm_estimated, "../rdata.files/gr_norm_growth_estimated.rds")
```

### Save list of ASVs with estimated growth rates

This will be used to subset sequences for PAPRICA.

```{r, eval = FALSE}
library(tidyverse)
gr.final <- readRDS(file="../rdata.files/gr_gr.final_rm0.rds")
gr.asvs <- gr.final %>% select(ASV) %>% unique()
write.txt(gr.asvs, file="")
```

# Figure

```{r}
# Import data (from script 04)
rm(list=ls())

# Microcosm data
ucosm <- readRDS(file="../rdata.files/gr_ucosm.norm.clean.rds")

# Growth rate estimations
gr.est <- readRDS(file="../rdata.files/gr_gr.final_rm0.rds")
```


```{r}
library(tidyverse)
library(cowplot)

# Clean up data frame
ucosm.clean <- ucosm %>%
  select(Soil, Amendment, Replicate, Day, ASV, Domain, Phylum, Class, Order, Class, Family, Genus, norm_abund) %>%
  filter(norm_abund > 0) %>% # remove 0s
  arrange(Day) # order by day
```

```{r}
# Example 1: Burkholderia
p1.estimate <- gr.est %>%
  filter(ASV=="13e4a5f455c50b2e805e017ca450ade2", Soil=="S17", Amendment=="Y", Replicate==1)
p1.data <- ucosm.clean %>%
  filter(ASV=="13e4a5f455c50b2e805e017ca450ade2", Soil=="S17", Amendment=="Y", Replicate==1)

p1 <- ggplot(p1.data, aes(x=Day, y=log(norm_abund))) +
  geom_point(color="black", shape=1) +
  geom_point(data = p1.data[p1.estimate$Start,], color="black") +
  geom_point(data = p1.data[p1.estimate$End,], color="black") +
  geom_line(color="#676366") +
  geom_smooth(method="lm", data=p1.data[p1.estimate$Start:p1.estimate$End,], color="black", fill="gray", linetype=2, size=0.7, alpha=0.5) +
  labs(title=paste("a. ", unique(p1.data$Phylum), ", ", unique(p1.data$Genus), sep=""), y="ln normalized abundance") +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(), 
        title = element_text(size=9),
        #plot.title = element_text(vjust = -5.5, hjust = -0.2),
        axis.line = element_line(colour = "black"),
        axis.title = element_blank(),
        axis.text = element_text(size = 9))
p1

# Example 2: Streptomyces
p2.estimate <- gr.est %>%
  filter(ASV=="aecae9d790a63cf565c1b5cdbd02ebdd", Soil=="C3", Amendment=="Y", Replicate==3)
p2.data <- ucosm.clean %>%
  filter(ASV=="aecae9d790a63cf565c1b5cdbd02ebdd", Soil=="C3", Amendment=="Y", Replicate==3)

p2 <- ggplot(p2.data, aes(x=Day, y=log(norm_abund))) +
  geom_point(color="black", shape=1) +
  geom_point(data = p2.data[p2.estimate$Start,], color="black") +
  geom_point(data = p2.data[p2.estimate$End,], color="black") +
  geom_line(color="#676366") +
  geom_smooth(method="lm", data=p2.data[p2.estimate$Start:p2.estimate$End,], color="black", fill="gray", linetype=2, size=0.7, fill="black", alpha=0.5) +
  labs(title=paste("b. ", unique(p2.data$Phylum), ", ", unique(p2.data$Genus), sep=""), y="Normalized abundance (ln)") +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        title = element_text(size=9),
        #plot.title = element_text(vjust = -6.5, hjust = 0.01),
        axis.line = element_line(colour = "black"),
        axis.title = element_blank(),
        axis.text = element_text(size = 9))
p2

# Example 3: Acidobacteria
p3.estimate <- gr.est %>%
  filter(ASV=="692a26188cb2e4528d0add62ea0d77f1", Soil=="C3", Amendment=="N", Replicate==1)
p3.data <- ucosm.clean %>%
  filter(ASV=="692a26188cb2e4528d0add62ea0d77f1", Soil=="C3", Amendment=="N", Replicate==1)

p3 <- ggplot(p3.data, aes(x=Day, y=log(norm_abund))) +
  geom_point(color="black", shape=1) +
  geom_point(data = p3.data[p3.estimate$Start,], color="black") +
  geom_point(data = p3.data[p3.estimate$End,], color="black") +
  geom_line(color="#676366") +
  geom_smooth(method="lm", data=p3.data[p3.estimate$Start:p3.estimate$End,], color="black", fill="gray", linetype=2, size=0.7, fill="black", alpha=0.5) +
  labs(title=paste("c. ", unique(p3.data$Phylum), ", ", unique(p3.data$Genus), sep=""), y="Normalized abundance (ln)") +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(), 
        title = element_text(size=9),
        #plot.title = element_text(vjust = -6.5, hjust = 0.01),
        axis.line = element_line(colour = "black"),
        axis.title = element_blank(),
        axis.text = element_text(size = 9))
p3

# Example 4: Planctomyces
p4.estimate <- gr.est %>%
  filter(ASV=="4b2544b81a01a3355506bfbba84889e1", Soil=="S17", Amendment=="Y", Replicate==3)
p4.data <- ucosm.clean %>%
  filter(ASV=="4b2544b81a01a3355506bfbba84889e1", Soil=="S17", Amendment=="Y", Replicate==3)

p4 <- ggplot(p4.data, aes(x=Day, y=log(norm_abund))) +
  geom_point(color="black", shape=1) +
  geom_point(data = p4.data[p4.estimate$Start,], color="black") +
  geom_point(data = p4.data[p4.estimate$End,], color="black") +
  geom_line(color="#676366") +
  geom_smooth(method="lm", data=p4.data[p4.estimate$Start:p4.estimate$End,], color="black", fill="gray", linetype=2, size=0.7, fill="black", alpha=0.5) +
  labs(title=paste("d. ", unique(p4.data$Phylum), ", ", unique(p4.data$Family), sep=""), y="Normalized abundance (ln)") +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(), 
        title = element_text(size=9),
        #plot.title = element_text(vjust = -6.5, hjust = 0.01),
        axis.line = element_line(colour = "black"),
        axis.title = element_blank(),
        axis.text = element_text(size = 9))
p4

example.curves <- plot_grid(p1, p2, p3, p4)
example.curves

ggsave(example.curves, file="../figures/fig_examplegrowth.svg", units="mm", width=185, height=95, device = "svg")
```

```{r}
# import tidied dataset
growth <- readRDS("../rdata.files/gr_gr.paprica.clean.rds")

growth_examples <- growth %>% 
  filter((Soil=="S17" & Amendment=="Y" & Replicate == 1 & ASV=="13e4a5f455c50b2e805e017ca450ade2") |
           (Soil=="C3" & Amendment=="Y" & Replicate == 3 & ASV=="aecae9d790a63cf565c1b5cdbd02ebdd") |
           (Soil=="C3" & Amendment=="N" & Replicate == 1 & ASV=="692a26188cb2e4528d0add62ea0d77f1") |
           (Soil=="S17" & Amendment=="Y" & Replicate == 3 & ASV=="4b2544b81a01a3355506bfbba84889e1")) %>% 
  arrange(start_day) %>% 
  mutate(change_abund = end_abund - start_abund)
```